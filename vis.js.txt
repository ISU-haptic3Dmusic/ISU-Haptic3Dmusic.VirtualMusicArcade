/*
default 1 .5 .6 .7;
1 HDEV/proxyPosition y _ .1;
1 HDEV/deviceVelocity _ x _;
2 HDEV/deviceVelocity x y r;
3 Surface force x _ y;
3 SAT/angleFromSurfaceNormal r;
*/
inlets = 4;
outlets = 3;

function Field() {
	this.route = "";
	this.index = -1;
	this.value = -1;
	Field.prototype.toString = function toString() {
		return "(route=" + this.route + ", index=" + this.index + ", value=" + this.value +")";
	}
}

function Node() {
	this.y = new Field();
	this.x = new Field();
	this.r = new Field();
	this.index = -1;
	this.cmd = function() {
		return "setnode " + this.index + " " + this.x.value + " " + this.y.value + " " + this.r.value;
	}
	Node.prototype.toString = function toString() {
		return "index:" + this.index + " x:" + this.x.toString() + " y:" + this.y.toString() + " r:" + this.r.toString();
	}
}
function scale(val, minin, maxin, minout, maxout) {

	return ((val-minin)/(maxin-minin))*(maxout-minout) + minout;

	/*var topin = minout - minin;
	val -= minin;
	var topout = maxout - minout;
	val *= topout / topin;
	val += minout;
	return val;*/
}
var nodesByIndex = new Object();
var globalmax;
var globalmin;

function anything() {
	if (inlet == 1) {
		//put this here to separate processing of ranges from parsing of input/mappings
		var input = arrayfromargs(messagename, arguments);
		var max = input[2];
		var min = input[2];
		for (var i = 3; i < input.length; i++) {
			if (input[i] > max) {
				max = input[i];
			}
			if (input[i] < min) {
				min = input[i];
			}
		}
		if (max > globalmax || globalmax == undefined) {
			globalmax = max;
		}
		if (min < globalmin || globalmin == undefined) {
			globalmin = min;
		}
	}

	if (inlet==3) {
		////////set up the mapping////////////////
		//reset all globals
		nodesByIndex = new Object();
		globalmin = undefined;
		globalmax = undefined;

		var str = "";
		for (var i = 0; i < arguments.length; i++) {
			str += arguments[i] + " ";
		}
		//post("str: " + str + "\n");
		var commands = str.split(";");
		//post("commands.length=" + commands.length+ "\n");
		//post("commands: " + commands + "\n");

		for (var i = 0; i < commands.length; i++) {
			if (commands[i].trim() == "") {
				continue;
			}
			var tokens = commands[i].trim().split(/\s+/);

			if (tokens[0] == "defaults") {
				var index = tokens[1];
				var node;
				if (nodesByIndex[index] != undefined) {
					node = nodesByIndex[index];
				} else {
					post("creating new\n");
					node = new Node();
					node.index = index;
				}
				if (!isNaN(tokens[2])) {
					node.x.value = tokens[2];
				}
				if (!isNaN(tokens[3])) {
					node.y.value = tokens[3];
				}
				if (!isNaN(tokens[4])) {
					node.r.value = tokens[4];
				}
				if (!(node in nodesByIndex)) {
					nodesByIndex[index] = node;
				}
			} else {
				//post("tokens " + i + ": " + tokens + "\n");
				var index = tokens[0];
				var field = tokens[1];
				var rtst = "/VESC/" + field + "/value";
				//post("rtst: " + rtst + "\n");
				var node;
				if (nodesByIndex[index] != undefined) {
					//post("found it\n");
					node = nodesByIndex[index];
				} else {
					//post("creating new\n");
					node = new Node();
				}
				//post(node.toString());
				//this will override any previously defined values
				for (var j = 2; j < tokens.length; j++) {
					if (tokens[j] == "x") {
						node.x.index = j-2;
						node.x.route = rtst;
					}
					if (tokens[j] == "y") {
						node.y.index = j-2;
						node.y.route = rtst;
					}
					if (tokens[j] == "r") {
						node.r.index = j-2;
						node.r.route = rtst;
					}
				}

				//TODO not sure if this is necessary if the node already existed in nodes
				node.index = index;
				if (!(node in nodesByIndex)) {
					nodesByIndex[index] = node;
				}
			}	
		}
		var max = -1;
		for (var key in nodesByIndex) {
			if (key > max) {
				max = key;
			}
		}
		if (max > -1) {
			outlet(0, "nodenumber " + max);
		}
		outlet(1, "bang");
	} else if (inlet == 1) {
		/////////set the values and output the node command/////////

		var input = arrayfromargs(messagename, arguments);
		//post("input: " + input + "\n");
		var matched = false;

		var rt = input[1];

		for (var i = 2; i < input.length; i++) {
			input[i] = scale(input[i], globalmin, globalmax, 0, 1);
		}

		//the index math in the block assumes correct user input
		for (var key in nodesByIndex) {
			var node = nodesByIndex[key];
			//post(node.toString());
			var set = false;
			if (node.y.route == rt) {
				node.y.value = input[node.y.index+2];
				set = true;
			}
			if (node.x.route == rt) {
				node.x.value = input[node.x.index+2];
				set = true;
			}
			if (node.r.route == rt) {
				node.r.value = input[node.r.index+2]/4.;
				set = true;
			}
			if (set) {
				outlet(0, node.cmd());
			}
		}
	} else if (inlet == 2) {
		for (var key in nodesByIndex) {
			var node = nodesByIndex[key];
			outlet(2, node.toString());
		}
	}
}
